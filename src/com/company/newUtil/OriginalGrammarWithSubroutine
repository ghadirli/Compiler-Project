PROGRAM -> DECLARATIONLIST eof
DECLARATIONLIST -> DECLARATION DECLARATIONLIST
DECLARATIONLIST -> epsilon
DECLARATION -> void #push_name id DECLARATION2
DECLARATION -> int #push_name id DECLARATION2
DECLARATION2 -> VARDECLARATION2
DECLARATION2 -> #func_addr_in_mem_save ( PARAMS ) COMPOUNDSTMT #func_jump
VARDECLARATION2 -> #variable_declare_addr ;
VARDECLARATION2 -> [ #array_declare_addr num ] ;
PARAMS -> int #push_name id PARAM2 PARAMLIST2
PARAMS -> void PARAMS2
PARAMS2 -> #void_error #push_name id PARAM2 PARAMLIST2
PARAMS2 -> epsilon
PARAMLIST2 -> , PARAMLIST3
PARAMLIST2 -> epsilon
PARAMLIST3 -> int #push_name id PARAM2 PARAMLIST2
PARAMLIST3 -> #void_error void id PARAM2 PARAMLIST2
PARAM2 -> [ #array_declare_addr_without_num ]
PARAM2 -> epsilon #variable_declare_addr_add_to_hashmap
COMPOUNDSTMT -> { DECLARATIONLIST STATEMENTLIST }
STATEMENTLIST -> STATEMENT STATEMENTLIST
STATEMENTLIST -> epsilon
STATEMENT -> EXPRESSIONSTMT
STATEMENT -> COMPOUNDSTMT
STATEMENT -> SELECTIONSTMT
STATEMENT -> ITERATIONSTMT
STATEMENT -> RETURNSTMT
STATEMENT -> SWITCHSTMT
EXPRESSIONSTMT -> EXPRESSION ; #pop1
EXPRESSIONSTMT -> continue ; #continue
EXPRESSIONSTMT -> break ; #break
EXPRESSIONSTMT -> ;
SELECTIONSTMT -> if ( EXPRESSION #save ) STATEMENT else #ifsjpf_save STATEMENT #ifsjp
ITERATIONSTMT -> while #new_breakable #new_continuable ( #label EXPRESSION #save ) STATEMENT #while
RETURNSTMT -> return RETURNSTMT2 #return
RETURNSTMT2 -> ;
RETURNSTMT2 -> EXPRESSION ;
SWITCHSTMT -> switch #new_breakable ( EXPRESSION ) { CASESTMTS DEFAULTSTMT } #end_of_switch
CASESTMTS -> CASESTMT CASESTMTS
CASESTMTS -> epsilon
CASESTMT -> case #jpf_save_case_and_push_num num : STATEMENTLIST
DEFAULTSTMT -> default : #default STATEMENTLIST
DEFAULTSTMT -> epsilon #default
EXPRESSION -> #pid id EXPRESSION2
EXPRESSION -> #push_to_stack_num num TERM2 ADDITIVEEXPRESSION2 SIMPLEEXPRESSION2
EXPRESSION -> ( EXPRESSION ) TERM2 ADDITIVEEXPRESSION2 SIMPLEEXPRESSION2
EXPRESSION -> + FACTOR TERM2 ADDITIVEEXPRESSION2 SIMPLEEXPRESSION2
EXPRESSION -> - FACTOR TERM2 ADDITIVEEXPRESSION2 SIMPLEEXPRESSION2
EXPRESSION2 -> VAR2 EXPRESSION3
EXPRESSION2 -> ( ARGS ) #fix_dollar_ra TERM2 ADDITIVEEXPRESSION2 SIMPLEEXPRESSION2
EXPRESSION3 -> = EXPRESSION #assign
EXPRESSION3 -> TERM2 ADDITIVEEXPRESSION2 SIMPLEEXPRESSION2
VAR2 -> [ EXPRESSION #bias_to_memory ]
VAR2 -> epsilon
SIMPLEEXPRESSION2 -> RELOP SIGNEDFACTOR TERM2 ADDITIVEEXPRESSION2 #lt_or_equal
SIMPLEEXPRESSION2 -> epsilon
RELOP -> < #push0
RELOP -> == #push1
ADDITIVEEXPRESSION2 -> ADDOP SIGNEDFACTOR TERM2 #sum_or_minus ADDITIVEEXPRESSION2
ADDITIVEEXPRESSION2 -> epsilon
ADDOP -> + #push0
ADDOP -> - #push1
TERM2 -> * SIGNEDFACTOR #mult TERM2
TERM2 -> epsilon
SIGNEDFACTOR -> FACTOR
SIGNEDFACTOR -> + FACTOR
SIGNEDFACTOR -> - FACTOR
FACTOR -> ( EXPRESSION )
FACTOR -> #pid id FACTOR2
FACTOR -> #push_to_stack_num num
FACTOR2 -> VAR2
FACTOR2 -> ( ARGS ) #fix_dollar_ra
ARGS -> ARGLIST
ARGS -> epsilon
ARGLIST -> EXPRESSION #assign_param ARGLIST2
ARGLIST2 -> , EXPRESSION #assign_param ARGLIST2
ARGLIST2 -> epsilon #final_assign_param